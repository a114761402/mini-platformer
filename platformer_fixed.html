<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Platformer (Mario-like)</title>
  <style>
    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; }
    #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { background: rgb(92,148,252); display:block; outline: none; }
    /* HUD */
    #hud {
      position: fixed; left: 12px; top: 10px;
      font: 20px/1.2 ui-monospace, Menlo, Consolas, monospace;
      color: #fff; text-shadow: 0 2px 0 rgba(0,0,0,.35);
      user-select: none; pointer-events: none;
    }
    /* Overlay */
    #overlay {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.35);
      color:#fff; text-align:center; padding: 24px;
      font: 18px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      user-select:none;
    }
    #overlay.hidden { display:none; }
    #overlay .card {
      max-width: 680px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 16px;
      padding: 18px 18px 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #overlay h1 { margin: 0 0 10px; font-size: 22px; }
    #overlay p { margin: 10px 0; opacity: .95; }
    #overlay .row { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:12px; }
    button {
      appearance:none; border:0; border-radius: 12px;
      padding: 10px 14px;
      font: 700 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      cursor:pointer;
      background: #fff; color:#111;
    }
    button.secondary { background: rgba(255,255,255,.18); color:#fff; border:1px solid rgba(255,255,255,.25); }
    /* On-screen controls */
    #controls {
      position: fixed; left: 0; right: 0; bottom: 0;
      padding: 10px 12px 14px;
      display:flex; justify-content:space-between; align-items:flex-end;
      gap: 12px;
      pointer-events: none; /* enable per-button */
    }
    .pad { display:flex; gap:10px; pointer-events:none; }
    .btn {
      width: 62px; height: 62px;
      border-radius: 18px;
      background: rgba(255,255,255,.18);
      border: 1px solid rgba(255,255,255,.25);
      color:#fff;
      font: 800 18px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display:grid; place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      pointer-events: auto;
    }
    .btn:active { transform: translateY(1px); }
    .hint {
      position: fixed; right: 12px; top: 10px;
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: rgba(255,255,255,.9);
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.18);
      padding: 8px 10px; border-radius: 12px;
      user-select:none;
    }
    @media (pointer:fine) {
      /* Hide touch controls on desktop by default */
      #controls { display:none; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" tabindex="0"></canvas>
  </div>

  <div id="hud">Score: <span id="score">0</span> · Level: <span id="level">1</span></div>
  <div class="hint">Move: ←/→ or A/D · Jump: Space/↑/W · Restart: Enter</div>

  <div id="overlay">
    <div class="card">
      <h1>Mini Platformer</h1>
      <p><b>Click / tap this screen once</b> to activate controls (some browsers block keys until you do).</p>
      <p>Then: <b>←/→</b> or <b>A/D</b> to move, <b>Space</b> (or ↑/W) to jump. Collect coins, avoid enemies, reach the green flag.</p>
      <div class="row">
        <button id="startBtn">Start</button>
        <button id="restartBtn" class="secondary">Restart</button>
      </div>
    </div>
  </div>

  <div id="controls">
    <div class="pad">
      <div class="btn" id="leftBtn">◀</div>
      <div class="btn" id="rightBtn">▶</div>
    </div>
    <div class="pad">
      <div class="btn" id="jumpBtn">⤒</div>
    </div>
  </div>

<script>
(() => {
  // --------- Helpers ---------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rectsOverlap = (a, b) => (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );

  // --------- Canvas setup ---------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");

  function resize() {
    // Logical resolution
    const baseW = 960;
    const baseH = 540;
    // Fit to screen
    const scale = Math.max(1, Math.floor(Math.min(window.innerWidth / baseW, window.innerHeight / baseH)));
    canvas.width = baseW * scale;
    canvas.height = baseH * scale;
    ctx.setTransform(scale, 0, 0, scale, 0, 0); // draw in base coords
    state.view.scale = scale;
    state.view.w = baseW;
    state.view.h = baseH;
  }
  window.addEventListener("resize", resize, { passive: true });

  // --------- Input ---------
  const input = {
    left: false,
    right: false,
    jumpPressed: false,   // edge-trigger
    jumpHeld: false,      // level-trigger
    anyActivated: false,
  };

  function activateControls() {
    input.anyActivated = true;
    overlay.classList.add("hidden");
    canvas.focus();
  }

  // Some browsers require a user gesture before key events are delivered to the page.
  overlay.addEventListener("pointerdown", activateControls);
  startBtn.addEventListener("click", activateControls);
  restartBtn.addEventListener("click", () => { activateControls(); resetLevel(true); });

  function onKey(e, down) {
    // prevent arrow keys from scrolling the page
    if (["ArrowLeft","ArrowRight","ArrowUp"," ","Spacebar"].includes(e.key)) e.preventDefault();

    if (!input.anyActivated) return; // require click/tap first

    const k = e.key.toLowerCase();
    if (k === "arrowleft" || k === "a") input.left = down;
    if (k === "arrowright" || k === "d") input.right = down;

    if (k === "arrowup" || k === "w" || k === " " || k === "spacebar") {
      input.jumpHeld = down;
      if (down) input.jumpPressed = true;
    }

    if ((k === "enter") && down) {
      resetLevel(true);
    }
  }

  window.addEventListener("keydown", (e) => onKey(e, true), { passive: false });
  window.addEventListener("keyup", (e) => onKey(e, false), { passive: false });

  // Touch / mouse buttons (always available)
  const hookHold = (el, field) => {
    const down = (e) => { e.preventDefault(); activateControls(); input[field] = true; };
    const up = (e) => { e.preventDefault(); input[field] = false; };
    el.addEventListener("pointerdown", down);
    el.addEventListener("pointerup", up);
    el.addEventListener("pointercancel", up);
    el.addEventListener("pointerleave", up);
  };
  hookHold(document.getElementById("leftBtn"), "left");
  hookHold(document.getElementById("rightBtn"), "right");

  const jumpBtn = document.getElementById("jumpBtn");
  jumpBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    activateControls();
    input.jumpHeld = true;
    input.jumpPressed = true;
  });
  const endJump = (e) => { e.preventDefault(); input.jumpHeld = false; };
  jumpBtn.addEventListener("pointerup", endJump);
  jumpBtn.addEventListener("pointercancel", endJump);
  jumpBtn.addEventListener("pointerleave", endJump);

  // --------- Level data ---------
  const TILE = 32;

  const levels = [
    [
      "................................................................",
      "................................................................",
      "................................................................",
      "...............c..............c.................................",
      "..........====...........====.............e.....................",
      "................................................................",
      "....c..................c.........................c..............",
      "====================..==================..======================",
      "P.............................................................F=",
      "=============================================================== ",
    ],
    [
      "................................................................",
      "................................................................",
      "....................c..............c............................",
      "..............====...........====...............e...............",
      "................................................................",
      "....c....................c..........................c...........",
      "==================..==================..===================..====",
      "................................................................",
      "P.............................................................F=",
      "=============================================================== ",
    ],
  ];

  // --------- Game state ---------
  const state = {
    levelIndex: 0,
    score: 0,
    status: "playing", // playing | win | lose
    view: { x: 0, y: 0, w: 960, h: 540, scale: 1 },
    solids: [],
    coins: [],
    enemies: [],
    flag: null,
    player: null,
    message: "",
  };

  function buildLevel(idx) {
    state.solids = [];
    state.coins = [];
    state.enemies = [];
    state.flag = null;
    state.player = null;
    state.status = "playing";
    state.message = "";
    levelEl.textContent = String(idx + 1);

    const map = levels[idx];
    let start = { x: 2*TILE, y: 2*TILE };

    for (let y = 0; y < map.length; y++) {
      const row = map[y];
      for (let x = 0; x < row.length; x++) {
        const ch = row[x];
        const wx = x * TILE;
        const wy = y * TILE;

        if (ch === "=") {
          state.solids.push({ x: wx, y: wy, w: TILE, h: TILE });
        } else if (ch === "c") {
          state.coins.push({ x: wx + 8, y: wy + 8, w: 16, h: 16, taken: false });
        } else if (ch === "e") {
          state.enemies.push({ x: wx + 2, y: wy + 2, w: 28, h: 28, vx: -70, vy: 0, alive: true });
        } else if (ch === "F") {
          state.flag = { x: wx, y: wy, w: TILE, h: TILE };
        } else if (ch === "P") {
          start = { x: wx, y: wy };
        }
      }
    }

    state.player = {
      x: start.x, y: start.y,
      w: 26, h: 30,
      vx: 0, vy: 0,
      onGround: false,
      face: 1,
    };

    // Center camera near player
    state.view.x = 0;
    state.view.y = 0;
  }

  function resetLevel(fullRestart) {
    if (fullRestart) {
      state.score = 0;
      scoreEl.textContent = String(state.score);
      state.levelIndex = 0;
    }
    buildLevel(state.levelIndex);
  }

  // --------- Physics ---------
  const GRAVITY = 2400;
  const MOVE_SPEED = 320;
  const JUMP_VELOCITY = 780;

  function collideSolids(body) {
    // returns collision normal-ish info
    let hitX = false, hitY = false;
    for (const s of state.solids) {
      if (!rectsOverlap(body, s)) continue;
      const ox1 = (body.x + body.w) - s.x;
      const ox2 = (s.x + s.w) - body.x;
      const oy1 = (body.y + body.h) - s.y;
      const oy2 = (s.y + s.h) - body.y;
      const minX = Math.min(ox1, ox2);
      const minY = Math.min(oy1, oy2);

      if (minX < minY) {
        // resolve X
        if (ox1 < ox2) body.x -= ox1;
        else body.x += ox2;
        hitX = true;
      } else {
        // resolve Y
        if (oy1 < oy2) {
          body.y -= oy1;
          hitY = true;
        } else {
          body.y += oy2;
          hitY = true;
        }
      }
    }
    return { hitX, hitY };
  }

  function stepCharacter(ch, dt) {
    // Horizontal intent
    let want = 0;
    if (input.left) want -= 1;
    if (input.right) want += 1;
    ch.vx = want * MOVE_SPEED;
    if (want !== 0) ch.face = want;

    // Jump (edge-trigger)
    if (input.jumpPressed) {
      input.jumpPressed = false;
      if (ch.onGround && state.status === "playing") {
        ch.vy = -JUMP_VELOCITY;
        ch.onGround = false;
      }
    }

    // Gravity
    ch.vy += GRAVITY * dt;

    // Integrate X
    ch.x += ch.vx * dt;
    collideSolids(ch);

    // Integrate Y
    ch.y += ch.vy * dt;
    const beforeY = ch.y;
    collideSolids(ch);

    // Ground check: if we got pushed up while moving down
    ch.onGround = false;
    if (ch.vy >= 0) {
      // probe 1px below
      const probe = { x: ch.x, y: ch.y + 1, w: ch.w, h: ch.h };
      for (const s of state.solids) {
        if (rectsOverlap(probe, s)) {
          ch.onGround = true;
          ch.vy = 0;
          break;
        }
      }
    }
  }

  function stepEnemy(en, dt) {
    if (!en.alive) return;

    // Gravity
    en.vy += GRAVITY * dt;

    // Patrol move
    en.x += en.vx * dt;
    collideSolids(en);

    // If hit wall, reverse
    // Quick probe: if enemy overlaps any solid after X resolution, flip direction by checking side contact
    // More robust: look ahead for ground
    const dir = Math.sign(en.vx) || 1;
    const aheadX = en.x + (dir > 0 ? en.w + 1 : -1);
    const footY = en.y + en.h + 2;
    const probe = { x: aheadX, y: footY, w: 2, h: 2 };
    let hasGroundAhead = false;
    for (const s of state.solids) {
      if (rectsOverlap(probe, s)) { hasGroundAhead = true; break; }
    }
    if (!hasGroundAhead) en.vx *= -1;

    // Y
    en.y += en.vy * dt;
    collideSolids(en);

    // clamp to avoid falling forever (level is finite)
    if (en.y > (levels[state.levelIndex].length * TILE) + 400) {
      en.alive = false;
    }
  }

  // --------- Game loop ---------
  let last = performance.now();

  function update(dt) {
    if (state.status !== "playing") return;

    stepCharacter(state.player, dt);

    // Coin collection
    for (const c of state.coins) {
      if (c.taken) continue;
      if (rectsOverlap(state.player, c)) {
        c.taken = true;
        state.score += 1;
        scoreEl.textContent = String(state.score);
      }
    }

    // Enemies
    for (const e of state.enemies) stepEnemy(e, dt);

    // Player vs enemy
    for (const e of state.enemies) {
      if (!e.alive) continue;
      if (!rectsOverlap(state.player, e)) continue;

      // stomp check: player coming down and player's bottom above enemy top
      const playerBottom = state.player.y + state.player.h;
      const enemyTop = e.y;
      const falling = state.player.vy > 0;
      if (falling && (playerBottom - enemyTop) < 18) {
        e.alive = false;
        state.player.vy = -JUMP_VELOCITY * 0.65; // bounce
        state.score += 3;
        scoreEl.textContent = String(state.score);
      } else {
        state.status = "lose";
        state.message = "Game Over — press Enter or Restart";
      }
    }

    // Win condition
    if (state.flag && rectsOverlap(state.player, state.flag)) {
      if (state.levelIndex < levels.length - 1) {
        state.levelIndex += 1;
        buildLevel(state.levelIndex);
      } else {
        state.status = "win";
        state.message = "You Win! — press Enter or Restart";
      }
    }

    // Fall off world
    if (state.player.y > (levels[state.levelIndex].length * TILE) + 500) {
      state.status = "lose";
      state.message = "Game Over — press Enter or Restart";
    }

    // Camera follow (x only; keep y stable)
    const worldW = levels[state.levelIndex][0].length * TILE;
    const viewW = state.view.w;
    state.view.x = clamp(state.player.x + state.player.w/2 - viewW/2, 0, Math.max(0, worldW - viewW));
    state.view.y = 0;
  }

  function draw() {
    // clear
    ctx.clearRect(0, 0, state.view.w, state.view.h);

    // camera transform
    ctx.save();
    ctx.translate(-state.view.x, -state.view.y);

    // Draw solids
    ctx.fillStyle = "rgb(141,90,34)";
    for (const s of state.solids) ctx.fillRect(s.x, s.y, s.w, s.h);

    // Draw coins
    ctx.fillStyle = "rgb(255,222,89)";
    for (const c of state.coins) {
      if (c.taken) continue;
      ctx.fillRect(c.x, c.y, c.w, c.h);
    }

    // Draw flag
    if (state.flag) {
      ctx.fillStyle = "rgb(0,200,70)";
      ctx.fillRect(state.flag.x, state.flag.y, state.flag.w, state.flag.h);
      ctx.fillStyle = "rgba(255,255,255,.9)";
      ctx.fillRect(state.flag.x + 10, state.flag.y + 6, 6, 20);
    }

    // Draw enemies
    for (const e of state.enemies) {
      if (!e.alive) continue;
      ctx.fillStyle = "rgb(255,0,0)";
      ctx.fillRect(e.x, e.y, e.w, e.h);
    }

    // Draw player (simple face ball-ish)
    const p = state.player;
    ctx.fillStyle = "rgb(40,200,120)";
    ctx.beginPath();
    ctx.ellipse(p.x + p.w/2, p.y + p.h/2, p.w/2, p.h/2, 0, 0, Math.PI*2);
    ctx.fill();

    // eyes
    ctx.fillStyle = "#111";
    const ex = (p.face >= 0) ? 1 : -1;
    ctx.beginPath(); ctx.arc(p.x + p.w/2 + ex*5, p.y + p.h/2 - 4, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(p.x + p.w/2 + ex*11, p.y + p.h/2 - 4, 2.2, 0, Math.PI*2); ctx.fill();
    // mouth
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(p.x + p.w/2 + ex*8, p.y + p.h/2 + 4, 7, 0, Math.PI, false);
    ctx.stroke();

    ctx.restore();

    // End state message
    if (state.status !== "playing") {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(0, 0, state.view.w, state.view.h);
      ctx.fillStyle = "#fff";
      ctx.font = "bold 40px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(state.status === "win" ? "YOU WIN!" : "GAME OVER", state.view.w/2, state.view.h/2 - 10);
      ctx.font = "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillText(state.message, state.view.w/2, state.view.h/2 + 26);
      ctx.restore();
    }
  }

  function loop(now) {
    const dt = clamp((now - last) / 1000, 0, 1/20);
    last = now;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // --------- Boot ---------
  resize();
  resetLevel(true);
  requestAnimationFrame(loop);

  // In case user clicks the canvas directly
  canvas.addEventListener("pointerdown", activateControls);
})();
</script>
</body>
</html>
