<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Prevent accidental pinch-zoom on mobile (fixes ‚Äúzoom in and can‚Äôt zoom out‚Äù) -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Mini Platformer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000;
      position: fixed; /* helps iOS avoid viewport bounce/scroll */
      inset: 0;
      touch-action: none; /* block pinch-zoom & scroll gestures */
    }

    /* Use dynamic viewport units to better fit mobile landscape/portrait with browser bars */
    canvas {
      position: fixed;
      left: 0; top: 0;
      width: 100dvw;
      height: 100dvh;
      display: block;
      outline: none;
      touch-action: none;
    }

    /* Full-canvas start overlay */
    #overlay {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.40);
      color:#fff; text-align:center; padding: 20px;
      font: 16px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      user-select:none;
    }
    #overlay.hidden { display:none; }
    #overlay .card {
      max-width: 760px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.22);
      border-radius: 16px;
      padding: 16px 16px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #overlay h1 { margin: 0 0 10px; font-size: 20px; }
    #overlay p { margin: 10px 0; opacity: .95; }
    #overlay .row { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:12px; }
    button {
      appearance:none; border:0; border-radius: 12px;
      padding: 10px 14px;
      font: 800 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      cursor:pointer;
      background: #fff; color:#111;
    }
    button.secondary { background: rgba(255,255,255,.18); color:#fff; border:1px solid rgba(255,255,255,.25); }

    /* Touch controls */
    #controls {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      padding: 10px 12px calc(14px + env(safe-area-inset-bottom));
      display: none;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      pointer-events: none;
    }
    .pad { display:flex; gap:10px; pointer-events:none; }
    .btn {
      width: 62px; height: 62px;
      border-radius: 18px;
      background: rgba(255,255,255,.18);
      border: 1px solid rgba(255,255,255,.25);
      color:#fff;
      font: 900 18px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display:grid; place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      pointer-events: auto;
    }
    .btn:active { transform: translateY(1px); }

    @media (pointer:coarse) {
      #controls { display:flex; }
    }
    /* Landscape phone: smaller buttons to keep more play area visible */
    @media (pointer:coarse) and (orientation: landscape) {
      #controls { padding: 6px 10px calc(10px + env(safe-area-inset-bottom)); }
      .btn { width: 54px; height: 54px; border-radius: 16px; font-size: 16px; }
      .pad { gap: 8px; }
    }
  </style>
</head>
<body>
  <canvas id="game" tabindex="0"></canvas>

  <div id="overlay">
    <div class="card">
      <h1>Mini Platformer</h1>
      <p><b>Tap / click once</b> to activate controls.</p>
      <p>
        Move: <b>‚Üê/‚Üí</b> or <b>A/D</b> ¬∑ Jump: <b>Space</b> (or <b>‚Üë/W</b>) ¬∑ New puzzle: <b>Enter</b><br/>
        Mobile: use buttons (‚óÄ ‚ñ∂ ‚§í ‚Üª). Works in <b>portrait + landscape</b>.
      </p>
      <div class="row">
        <button id="startBtn">Start</button>
        <button id="newBtn" class="secondary">New Puzzle</button>
      </div>
    </div>
  </div>

  <div id="controls">
    <div class="pad">
      <div class="btn" id="leftBtn">‚óÄ</div>
      <div class="btn" id="rightBtn">‚ñ∂</div>
    </div>
    <div class="pad">
      <div class="btn" id="renewBtn">‚Üª</div>
      <div class="btn" id="jumpBtn">‚§í</div>
    </div>
  </div>

<script>
(() => {
  // ---------- HARD block pinch/gesture zoom (esp. iOS Safari) ----------
  // Prevent two-finger pinch from ever zooming the page.
  document.addEventListener("touchmove", (e) => {
    if (e.touches && e.touches.length > 1) e.preventDefault();
  }, { passive: false });

  // iOS Safari gesture events
  ["gesturestart", "gesturechange", "gestureend"].forEach(evt => {
    document.addEventListener(evt, (e) => e.preventDefault(), { passive: false });
  });

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rectsOverlap = (a, b) => (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );

  // RNG (Mulberry32)
  function makeRng(seed) {
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let x = t;
      x = Math.imul(x ^ (x >>> 15), x | 1);
      x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }
  function newSeed() {
    const u = new Uint32Array(1);
    crypto.getRandomValues(u);
    return u[0] >>> 0;
  }
  const randInt = (rng, a, b) => (a + Math.floor(rng() * (b - a + 1)));
  const pick = (rng, arr) => arr[Math.floor(rng() * arr.length)];

  // ---------- Canvas (true full-screen; better in landscape via visualViewport) ----------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });
  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const newBtn = document.getElementById("newBtn");

  const dpr = () => Math.max(1, Math.min(3, window.devicePixelRatio || 1));

  const state = {
    runIndex: 1,
    seed: 0,
    score: 0,
    status: "playing",
    message: "",
    view: { x: 0, y: 0, w: 360, h: 640 },
    world: { wTiles: 140, hTiles: 18, groundY: 16 },
    solids: [],
    coins: [],
    enemies: [],
    flag: null,
    player: null,
    popups: [],
  };

  function resize() {
    // visualViewport better matches what you can actually see in mobile landscape
    const vv = window.visualViewport;
    const w = Math.max(1, vv ? vv.width : window.innerWidth);
    const h = Math.max(1, vv ? vv.height : window.innerHeight);

    const r = dpr();
    canvas.width = Math.floor(w * r);
    canvas.height = Math.floor(h * r);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(r, 0, 0, r, 0, 0);

    state.view.w = w;
    state.view.h = h;
  }

  window.addEventListener("resize", resize, { passive: true });
  if (window.visualViewport) window.visualViewport.addEventListener("resize", resize, { passive: true });

  // ---------- Input ----------
  const input = { left:false, right:false, jumpPressed:false, jumpHeld:false, anyActivated:false };

  function activateControls() {
    input.anyActivated = true;
    overlay.classList.add("hidden");
    canvas.focus();
  }

  overlay.addEventListener("pointerdown", activateControls);
  startBtn.addEventListener("click", activateControls);
  newBtn.addEventListener("click", () => { activateControls(); resetRun(true); });

  function onKey(e, down) {
    if (["ArrowLeft","ArrowRight","ArrowUp"," ","Spacebar"].includes(e.key)) e.preventDefault();
    if (!input.anyActivated) return;

    const k = e.key.toLowerCase();
    if (k === "arrowleft" || k === "a") input.left = down;
    if (k === "arrowright" || k === "d") input.right = down;
    if (k === "arrowup" || k === "w" || k === " " || k === "spacebar") {
      input.jumpHeld = down;
      if (down) input.jumpPressed = true;
    }
    if (k === "enter" && down) resetRun(true);
  }
  window.addEventListener("keydown", (e) => onKey(e, true), { passive:false });
  window.addEventListener("keyup", (e) => onKey(e, false), { passive:false });

  const hookHold = (el, field) => {
    const down = (e) => { e.preventDefault(); activateControls(); input[field] = true; };
    const up = (e) => { e.preventDefault(); input[field] = false; };
    el.addEventListener("pointerdown", down);
    el.addEventListener("pointerup", up);
    el.addEventListener("pointercancel", up);
    el.addEventListener("pointerleave", up);
  };
  hookHold(document.getElementById("leftBtn"), "left");
  hookHold(document.getElementById("rightBtn"), "right");

  const jumpBtn = document.getElementById("jumpBtn");
  jumpBtn.addEventListener("pointerdown", (e) => { e.preventDefault(); activateControls(); input.jumpHeld = true; input.jumpPressed = true; });
  const endJump = (e) => { e.preventDefault(); input.jumpHeld = false; };
  jumpBtn.addEventListener("pointerup", endJump);
  jumpBtn.addEventListener("pointercancel", endJump);
  jumpBtn.addEventListener("pointerleave", endJump);

  document.getElementById("renewBtn").addEventListener("pointerdown", (e) => {
    e.preventDefault(); activateControls(); resetRun(true);
  });

  canvas.addEventListener("pointerdown", activateControls);

  // ---------- Game constants ----------
  const TILE = 32;
  const GRAVITY = 2400;
  const BASE_MOVE_SPEED = 320;
  const JUMP_VELOCITY = 780;

  function jumpTimeToDeltaY(dyPx) {
    const V = JUMP_VELOCITY, G = GRAVITY;
    if (dyPx >= 0) return (V + Math.sqrt(V*V + 2*G*dyPx)) / G;
    const h = -dyPx;
    const disc = V*V - 2*G*h;
    if (disc <= 0) return null;
    return (V - Math.sqrt(disc)) / G;
  }
  function maxHorizontalReach(dyPx, moveSpeed) {
    const t = jumpTimeToDeltaY(dyPx);
    if (t == null) return 0;
    return moveSpeed * t;
  }
  const MAX_JUMP_HEIGHT_PX = (JUMP_VELOCITY * JUMP_VELOCITY) / (2 * GRAVITY);

  function addScore(points) { state.score += points; }
  function addPopup(x, y, text, ttl=0.9) { state.popups.push({ x, y, text, ttl }); }

  // ---------- Collision ----------
  function resolveX(body) {
    for (const s of state.solids) {
      if (!rectsOverlap(body, s)) continue;
      if (body.vx > 0) body.x = s.x - body.w;
      else if (body.vx < 0) body.x = s.x + s.w;
      body.vx = 0;
    }
  }
  function resolveY(body) {
    let hitQ = null;
    for (const s of state.solids) {
      if (!rectsOverlap(body, s)) continue;
      if (body.vy > 0) {
        body.y = s.y - body.h;
        body.vy = 0;
        body.onGround = true;
      } else if (body.vy < 0) {
        body.y = s.y + s.h;
        body.vy = 0;
        if (s.type === "qblock") hitQ = s;
      }
    }
    if (hitQ) onHitQBlock(hitQ);
  }

  // ---------- '?' rewards ----------
  const REWARDS = [
    { id: "coins",      w: 0.40 },
    { id: "superjump",  w: 0.18 },
    { id: "speed",      w: 0.18 },
    { id: "shield",     w: 0.14 },
    { id: "oops_enemy", w: 0.10 },
  ];
  function weightedPick(rng, items) {
    const total = items.reduce((s,it)=>s+it.w, 0);
    let r = rng() * total;
    for (const it of items) { r -= it.w; if (r <= 0) return it.id; }
    return items[items.length-1].id;
  }
  function onHitQBlock(block) {
    if (block.used) return;
    block.used = true;
    block.bump = 0.14;

    const rng = makeRng((state.seed ^ (block.x|0) ^ ((block.y|0)<<1)) >>> 0);
    const reward = block.reward || weightedPick(rng, REWARDS);
    block.reward = reward;

    const cx = block.x + block.w/2;
    const cy = block.y;

    addScore(5);
    addPopup(cx, cy - 10, "+5", 0.8);

    const p = state.player;
    if (reward === "coins") {
      addPopup(cx, cy - 28, "COINS!", 0.9);
      for (let i = 0; i < 3; i++) {
        state.coins.push({ x: block.x + 8, y: block.y - 18 - i*18, w: 16, h: 16, taken:false, ttl: 0.9, isBurst:true });
      }
      addScore(3);
    } else if (reward === "superjump") {
      addPopup(cx, cy - 28, "BOING!", 0.9);
      p.vy = -JUMP_VELOCITY * 1.35;
      addScore(2);
    } else if (reward === "speed") {
      addPopup(cx, cy - 28, "SPEED!", 0.9);
      p.speedT = 4.5;
      addScore(2);
    } else if (reward === "shield") {
      addPopup(cx, cy - 28, "SHIELD!", 0.9);
      p.invulnT = 4.5;
      addScore(2);
    } else if (reward === "oops_enemy") {
      addPopup(cx, cy - 28, "UH-OH üòà", 0.9);
      state.enemies.push({ x: block.x + 2, y: block.y - 30, w: 28, h: 28, vx: (rng()<0.5?-1:1) * 90, vy: 0, alive: true });
      addScore(1);
    }
  }

  // ---------- Solvable generation ----------
  function generateSolvableLevel(seed, difficulty) {
    const rng = makeRng(seed);
    const wTiles = clamp(95 + difficulty * 18, 95, 160);
    const hTiles = 18;
    const groundY = 16;
    state.world = { wTiles, hTiles, groundY };

    const solids = [];
    const coins = [];
    const enemies = [];

    const solidAt = (tx, ty, type, extra={}) => {
      solids.push({ x: tx*TILE, y: ty*TILE, w: TILE, h: TILE, type, ...extra });
    };

    // Ground with pits
    const pitCount = clamp(6 + difficulty * 4, 6, 16);
    const pits = [];
    for (let i = 0; i < pitCount; i++) pits.push({ x: randInt(rng, 10, wTiles - 15), w: randInt(rng, 2, 4) });
    pits.sort((a,b)=>a.x-b.x);
    const pitsMerged = [];
    for (const p of pits) {
      const last = pitsMerged[pitsMerged.length-1];
      if (last && p.x <= last.x + last.w + 2) last.w = Math.max(last.w, (p.x + p.w) - last.x);
      else pitsMerged.push({ ...p });
    }
    const isPit = (tx) => pitsMerged.some(p => tx >= p.x && tx < p.x + p.w);

    for (let x = 0; x < wTiles; x++) {
      if (x < 8 || x > wTiles - 10) { solidAt(x, groundY, "ground"); continue; }
      if (!isPit(x)) solidAt(x, groundY, "ground");
    }

    // Critical path (physics constrained)
    const segments = [];
    let x = 2, y = groundY - 1;
    const endTarget = wTiles - 8;

    const SAFE_SPEED = BASE_MOVE_SPEED * 0.90;
    const maxUpTiles = Math.floor((MAX_JUMP_HEIGHT_PX * 0.85) / TILE);

    while (x < endTarget) {
      const len = randInt(rng, 5, 9);
      segments.push({ x, y, len });

      const dyTiles = randInt(rng, -Math.min(maxUpTiles, 4), 4);
      const nextY = clamp(y + dyTiles, groundY - 10, groundY - 1);

      const dyPx = (nextY - y) * TILE;
      const maxDxPx = maxHorizontalReach(dyPx, SAFE_SPEED) * 0.88;
      const maxDxTiles = Math.max(3, Math.floor(maxDxPx / TILE));

      const gap = randInt(rng, 2, clamp(maxDxTiles - len, 2, 10));
      const nextX = x + len + gap;

      x = nextX;
      y = nextY;

      if (x >= endTarget - 12) break;
    }

    if (!segments.length) segments.push({ x: 2, y: groundY-1, len: 8 });
    const last = segments[segments.length-1];
    if (last.x + last.len < endTarget - 2) {
      segments.push({ x: endTarget - 8, y: clamp(last.y + randInt(rng, -1, 1), groundY-10, groundY-1), len: 10 });
    }

    for (const seg of segments) for (let i = 0; i < seg.len; i++) solidAt(seg.x + i, seg.y, "ground");

    const start = { x: 2*TILE, y: (groundY - 1)*TILE };
    const flagSeg = segments[segments.length-1];
    const flag = { x: (flagSeg.x + flagSeg.len - 1)*TILE, y: (flagSeg.y - 1)*TILE, w: TILE, h: TILE };
    solidAt(flagSeg.x + flagSeg.len - 1, flagSeg.y, "ground");

    // Coins
    for (const seg of segments) {
      if (rng() < 0.65) {
        const count = randInt(rng, 1, 3);
        for (let i = 0; i < count; i++) {
          const tx = seg.x + randInt(rng, 0, seg.len - 1);
          const ty = seg.y - randInt(rng, 1, 3);
          coins.push({ x: tx*TILE + 8, y: ty*TILE + 8, w: 16, h: 16, taken:false });
        }
      }
    }

    // '?' blocks (reachable but not required)
    const qCount = clamp(10 + difficulty * 6, 10, 28);
    const minAbove = 2;
    const maxAbove = clamp(maxUpTiles, 2, 4);
    for (let i = 0; i < qCount; i++) {
      const seg = pick(rng, segments);
      const tx = seg.x + randInt(rng, 0, seg.len - 1);
      const above = randInt(rng, minAbove, maxAbove);
      const ty = seg.y - above;
      if (ty < 2) continue;
      if (above === 2 && rng() < 0.5) continue;
      solidAt(tx, ty, "qblock", { used:false, bump:0, reward:null });
    }

    // Enemies
    const enemyCount = clamp(3 + difficulty * 2, 3, 10);
    for (let i = 0; i < enemyCount; i++) {
      const seg = pick(rng, segments.slice(Math.min(1, segments.length-1)));
      const tx = seg.x + randInt(rng, 0, seg.len - 1);
      const ty = seg.y - 1;
      enemies.push({ x: tx*TILE + 2, y: ty*TILE + 2, w: 28, h: 28, vx: (rng()<0.5?-1:1) * randInt(rng, 60, 110), vy: 0, alive: true });
    }

    return { solids, coins, enemies, start, flag };
  }

  function buildRun(seed) {
    const difficulty = clamp(state.runIndex - 1, 0, 5);
    const lvl = generateSolvableLevel(seed, difficulty);

    state.seed = seed;
    state.solids = lvl.solids;
    state.coins = lvl.coins;
    state.enemies = lvl.enemies;
    state.flag = lvl.flag;

    state.status = "playing";
    state.message = "";
    state.popups = [];

    state.player = {
      x: lvl.start.x, y: lvl.start.y, w: 26, h: 30,
      vx: 0, vy: 0,
      onGround: false,
      face: 1,
      invulnT: 0,
      speedT: 0,
    };

    state.view.x = 0; state.view.y = 0;
  }

  function resetRun(newPuzzle) {
    if (newPuzzle) {
      state.score = 0;
      state.runIndex += 1;
    }
    buildRun(newSeed());
  }

  // ---------- Movement + combat ----------
  function stepPlayer(dt) {
    const p = state.player;
    p.invulnT = Math.max(0, p.invulnT - dt);
    p.speedT  = Math.max(0, p.speedT - dt);

    const speed = (p.speedT > 0) ? BASE_MOVE_SPEED * 1.45 : BASE_MOVE_SPEED;

    let want = 0;
    if (input.left) want -= 1;
    if (input.right) want += 1;

    p.vx = want * speed;
    if (want !== 0) p.face = want;

    if (input.jumpPressed) {
      input.jumpPressed = false;
      if (p.onGround && state.status === "playing") {
        p.vy = -JUMP_VELOCITY;
        p.onGround = false;
      }
    }

    p.vy += GRAVITY * dt;

    p.x += p.vx * dt;
    resolveX(p);

    p.onGround = false;
    p.y += p.vy * dt;
    resolveY(p);

    // Coins
    for (const c of state.coins) {
      if (c.taken) continue;
      if (rectsOverlap(p, c)) {
        c.taken = true;
        addScore(c.isBurst ? 0 : 1);
        if (!c.isBurst) addPopup(c.x + 8, c.y, "+1", 0.5);
      }
    }
    for (const c of state.coins) {
      if (!c.isBurst || c.taken) continue;
      c.ttl -= dt;
      c.y -= 120 * dt;
      if (c.ttl <= 0) c.taken = true;
    }

    // Win
    if (state.flag && rectsOverlap(p, state.flag)) {
      state.status = "win";
      state.message = "You Win! Enter/‚Üª = new puzzle";
      addScore(10);
    }

    // Fall off
    const worldHpx = state.world.hTiles * TILE;
    if (p.y > worldHpx + 600) {
      state.status = "lose";
      state.message = "Game Over ‚Äî Enter/‚Üª to retry";
    }

    // Camera X
    const worldWpx = state.world.wTiles * TILE;
    const viewW = state.view.w;
    state.view.x = clamp(p.x + p.w/2 - viewW/2, 0, Math.max(0, worldWpx - viewW));
    state.view.y = 0;
  }

  function stepEnemy(e, dt) {
    if (!e.alive) return;

    e.vy += GRAVITY * dt;

    e.x += e.vx * dt;
    for (const s of state.solids) {
      if (!rectsOverlap(e, s)) continue;
      if (e.vx > 0) e.x = s.x - e.w;
      else if (e.vx < 0) e.x = s.x + s.w;
      e.vx *= -1;
    }

    const dir = Math.sign(e.vx) || 1;
    const aheadX = e.x + (dir > 0 ? e.w + 1 : -1);
    const footY = e.y + e.h + 2;
    const probe = { x: aheadX, y: footY, w: 2, h: 2 };
    let hasGroundAhead = false;
    for (const s of state.solids) {
      if (s.type !== "ground") continue;
      if (rectsOverlap(probe, s)) { hasGroundAhead = true; break; }
    }
    if (!hasGroundAhead) e.vx *= -1;

    e.y += e.vy * dt;
    for (const s of state.solids) {
      if (!rectsOverlap(e, s)) continue;
      if (e.vy > 0) { e.y = s.y - e.h; e.vy = 0; }
      else if (e.vy < 0) { e.y = s.y + s.h; e.vy = 0; }
    }

    const worldHpx = state.world.hTiles * TILE;
    if (e.y > worldHpx + 600) e.alive = false;
  }

  function stepEnemiesAndCombat(dt) {
    if (state.status !== "playing") return;
    const p = state.player;

    for (const e of state.enemies) stepEnemy(e, dt);

    for (const e of state.enemies) {
      if (!e.alive) continue;
      if (!rectsOverlap(p, e)) continue;

      const playerBottom = p.y + p.h;
      const enemyTop = e.y;
      const falling = p.vy > 0;

      if (falling && (playerBottom - enemyTop) < 18) {
        e.alive = false;
        p.vy = -JUMP_VELOCITY * 0.6;
        addScore(3);
        addPopup(e.x + 14, e.y, "+3", 0.7);
      } else {
        if (p.invulnT > 0) {
          p.vx = -p.vx * 0.6;
          p.vy = -JUMP_VELOCITY * 0.35;
          addPopup(p.x + 10, p.y - 10, "SHIELD!", 0.5);
        } else {
          state.status = "lose";
          state.message = "Game Over ‚Äî Enter/‚Üª to retry";
        }
      }
    }
  }

  function stepPopups(dt) {
    for (const pop of state.popups) {
      pop.ttl -= dt;
      pop.y -= 24 * dt;
    }
    state.popups = state.popups.filter(p => p.ttl > 0);
  }

  // ---------- Render ----------
  function drawHUD() {
    const pad = 12;
    const font = "700 18px ui-monospace, Menlo, Consolas, monospace";

    // Score + Run (top-left)
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = font;
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.lineWidth = 4;

    const s1 = `Score: ${state.score}`;
    const s2 = `Run: ${state.runIndex}`;

    ctx.strokeText(s1, pad, pad);
    ctx.fillText(s1, pad, pad);
    ctx.strokeText(s2, pad, pad + 22);
    ctx.fillText(s2, pad, pad + 22);

    // Author: C Lu (top-middle, same format)
    const author = "Author: C Lu";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.font = font;
    ctx.strokeText(author, state.view.w / 2, pad);
    ctx.fillText(author, state.view.w / 2, pad);

    // Powerup timers (under score)
    const p = state.player;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    let y = pad + 48;
    const tags = [];
    if (p.speedT > 0) tags.push(`SPEED ${p.speedT.toFixed(1)}s`);
    if (p.invulnT > 0) tags.push(`SHIELD ${p.invulnT.toFixed(1)}s`);
    if (tags.length) {
      ctx.fillStyle = "rgba(255,255,255,.9)";
      ctx.strokeStyle = "rgba(0,0,0,.35)";
      ctx.lineWidth = 3;
      for (const t of tags) {
        ctx.strokeText(t, pad, y);
        ctx.fillText(t, pad, y);
        y += 18;
      }
    }
  }

  function draw() {
    // Sky
    ctx.fillStyle = "rgb(92,148,252)";
    ctx.fillRect(0, 0, state.view.w, state.view.h);

    // Camera
    ctx.save();
    ctx.translate(-state.view.x, -state.view.y);

    // Solids
    for (const s of state.solids) {
      if (s.type === "ground") {
        ctx.fillStyle = "rgb(141,90,34)";
        ctx.fillRect(s.x, s.y, s.w, s.h);
      } else if (s.type === "qblock") {
        const bump = s.bump ? Math.max(0, s.bump) : 0;
        const by = s.y - bump * 18;
        ctx.fillStyle = s.used ? "rgb(160,160,160)" : "rgb(255,210,0)";
        ctx.fillRect(s.x, by, s.w, s.h);
        ctx.fillStyle = s.used ? "rgba(0,0,0,.35)" : "rgba(0,0,0,.60)";
        ctx.font = "900 18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("?", s.x + s.w/2, by + s.h/2 + 1);
        if (s.bump) s.bump -= 1/60;
      }
    }

    // Coins
    ctx.fillStyle = "rgb(255,222,89)";
    for (const c of state.coins) {
      if (c.taken) continue;
      ctx.fillRect(c.x, c.y, c.w, c.h);
    }

    // Flag
    if (state.flag) {
      ctx.fillStyle = "rgb(0,200,70)";
      ctx.fillRect(state.flag.x, state.flag.y, state.flag.w, state.flag.h);
      ctx.fillStyle = "rgba(255,255,255,.9)";
      ctx.fillRect(state.flag.x + 10, state.flag.y + 6, 6, 20);
    }

    // Enemies
    for (const e of state.enemies) {
      if (!e.alive) continue;
      ctx.fillStyle = "rgb(255,0,0)";
      ctx.fillRect(e.x, e.y, e.w, e.h);
    }

    // Player
    const p = state.player;
    ctx.fillStyle = (p.invulnT > 0) ? "rgb(180,255,180)" : "rgb(40,200,120)";
    ctx.beginPath();
    ctx.ellipse(p.x + p.w/2, p.y + p.h/2, p.w/2, p.h/2, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "#111";
    const ex = (p.face >= 0) ? 1 : -1;
    ctx.beginPath(); ctx.arc(p.x + p.w/2 + ex*5, p.y + p.h/2 - 4, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(p.x + p.w/2 + ex*11, p.y + p.h/2 - 4, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(p.x + p.w/2 + ex*8, p.y + p.h/2 + 4, 7, 0, Math.PI, false);
    ctx.stroke();

    ctx.restore();

    // Popups
    ctx.save();
    ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for (const pop of state.popups) {
      const sx = pop.x - state.view.x;
      const sy = pop.y - state.view.y;
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.strokeStyle = "rgba(0,0,0,.35)";
      ctx.lineWidth = 4;
      ctx.strokeText(pop.text, sx, sy);
      ctx.fillText(pop.text, sx, sy);
    }
    ctx.restore();

    // HUD
    drawHUD();

    // End screen
    if (state.status !== "playing") {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(0, 0, state.view.w, state.view.h);
      ctx.fillStyle = "#fff";
      ctx.font = "900 40px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(state.status === "win" ? "YOU WIN!" : "GAME OVER", state.view.w/2, state.view.h/2 - 18);
      ctx.font = "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillText(state.message, state.view.w/2, state.view.h/2 + 18);
      ctx.restore();
    }
  }

  // ---------- Loop ----------
  let last = performance.now();
  function loop(now) {
    const dt = clamp((now - last) / 1000, 0, 1/20);
    last = now;

    if (state.status === "playing") {
      stepPlayer(dt);
      stepEnemiesAndCombat(dt);
      stepPopups(dt);
    } else {
      stepPopups(dt);
    }
    draw();
    requestAnimationFrame(loop);
  }

  // ---------- Boot ----------
  resize();
  buildRun(newSeed());
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
